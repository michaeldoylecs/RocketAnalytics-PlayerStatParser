// Author: Michael Doyle
// Date: 1/28/18
// RocketAnalyticsPlayerStatParser.cpp

#include <map>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include <experimental/filesystem>
#include "ReplayFile.hpp"
#include "Player.hpp"

using namespace PlayerStatParser;
using namespace ReplayParser;

using std::vector;
using std::string;
using std::cout;
using std::cin;
using std::clog;
using std::endl;
using std::vector;
using std::pair;
using std::ofstream;
using std::stringstream;

namespace filesystem = std::experimental::filesystem::v1;

void set_mvp(vector<Player>& player_records, int winning_team);
vector<vector<Property>> get_stats(const vector<Property>& properties);
int get_winning_team(const vector<Property>& properties);
string create_stat_csv(const vector<Player>& players);

int main() {
	const string version = "1.2";
	const string default_file_name = "player_stats";
	const string file_extension = ".csv";
	vector<Player> players;
	string replay_dir;
	string dest_dir;

	cout << 
		"**************************************************\n" <<
		"******** RocketAnalytics-PlayerStatParser ********\n" <<
		"********* Author: Michael Doyle (MimiKe) *********\n" <<
		"****************** Version " << version << " *******************\n" <<
		"**************************************************\n" << endl;

	cout << "Please enter the directory path of the replay files:" << endl;
	cin >> replay_dir;

	if (!filesystem::is_directory(replay_dir)) {
		clog << "\nInvalid replay directory path!"<< endl;
		exit(EXIT_FAILURE);
	}

	cout << endl;
	cout << "Please enter the destination directory path:" << endl;
	cin >> dest_dir;

	if (!filesystem::is_directory(replay_dir)) {
		clog << "Invalid output directory path!\n" << endl;
		cin.get();
	}

	// Iterates through each file in the replay directory and parses the
	// replay header information. Then, it takes the PlayerStats property
	// and stores each player into a map. If the player already exists, the
	// stats are added together and stored.
	for (filesystem::path path : filesystem::directory_iterator(replay_dir)) {
		string replay_path = path.u8string();
		cout << "Parsing " << replay_path << "\n";

		ReplayFile replay(replay_path);
		vector<Property> properties = replay.get_header().get_properties();
		vector<vector<Property>> player_stats = get_stats(properties);
		int winning_team = get_winning_team(properties);

		vector<Player> player_stat_records;
		for (const auto& player_info : player_stats) {
			Player player(player_info);
			player_stat_records.push_back(player);
		}
		set_mvp(player_stat_records, winning_team);

		players.insert(
			players.begin(),
			player_stat_records.begin(),
			player_stat_records.end());
	}

	cout << endl;

	string output_file_name;
	cout << "Please enter the output filename (no spaces):" << endl;
	cin >> output_file_name;

	string output_filepath = dest_dir + "\\" + output_file_name + file_extension;

	ofstream output_file(output_filepath);
	output_file << create_stat_csv(players);
	output_file.close();

	return 0;
}

void set_mvp(vector<Player>& player_records, int winning_team) {
	Player highest_score_player;

	for (auto& player : player_records) {
		if (player.team == winning_team &&
			player.score > highest_score_player.score) {
			highest_score_player = player;
		}
	}

	for (auto& player : player_records) {
		if (player.onlineID == highest_score_player.onlineID) {
			++player.mvp;
			return;
		}
	}
}

vector<vector<Property>> get_stats(const vector<Property>& properties) {
	vector<vector<Property>> stats;
	for (Property prop : properties) {
		if (prop.get_name() == "PlayerStats") {
			stats = prop.get_value().property_value.list;
			break;
		}
	}
	return stats;
}

int get_winning_team(const vector<Property>& properties) {
	int team_0_score = 0;
	int team_1_score = 0;
	for (Property prop : properties) {
		if (prop.get_name() == "Team0Score") {
			team_0_score = prop.get_value().property_value.int32;
		}
		else if (prop.get_name() == "Team1Score") {
			team_1_score = prop.get_value().property_value.int32;
		}
	}
	return team_0_score > team_1_score ? 0 : 1;
}

string create_stat_csv(const vector<Player>& players) {
	stringstream csv;
	csv << "Player Stats generated by RocketAnalyticsPlayerStatsParser.\n" <<
		"Unique ID,Team,Name,Platform,Online ID,Games Played,MVPs,Score," <<
		"Goals,Assists,Saves,Shots\n";

	int count = 1;
	for (auto const& player : players) {
		csv <<
			count << ",," <<
			player.name << "," <<
			player.platform << "," <<
			player.onlineID << "," <<
			player.games << "," <<
			player.mvp << "," <<
			player.score << "," <<
			player.goals << "," <<
			player.assists << "," <<
			player.saves << "," <<
			player.shots << "\n";
		count++;
	}
	csv.flush();
	return csv.str();
}
